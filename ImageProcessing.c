/* * FinalProject.c * *	A collection of image processing algorithms * *  Created on: September 30, 2014 *      Author: Abhishek Barla * *      Code allows for potential anaglyph 3D creation */// ============== INCLUDES ===============#include <std.h>#include "GaussianFilter.h"#include "DiskBlur.h"// ============== DEFINES ================#define XSIZE		400#define YSIZE		300#define NUM_PIXELS	(XSIZE * YSIZE)// ============== GLOBAL DEFINITIONS =====#pragma DATA_SECTION(imgBuffer, "myDDR2");#pragma DATA_SECTION(newImg, "myDDR2");#pragma DATA_SECTION(tempBuffer, "myDDR2");unsigned int imgBuffer[NUM_PIXELS];unsigned int newImg[NUM_PIXELS];unsigned int tempBuffer[NUM_PIXELS];#pragma DATA_SECTION(Red,"myDDR2");unsigned int Red[25];#pragma DATA_SECTION(Green,"myDDR2");unsigned int Green[25];#pragma DATA_SECTION(Blue,"myDDR2");unsigned int Blue[25];int BWModifier = 8;int pixelModifier = 10;int embossDepth = 2;int detectionParameter = 1;int detectThreshold= 20;void BlackandWhite();void pixelate();void emboss();void edgeDetection();void gaussianBlur();void diskBlur();void main(void){	//pixelate(); // create a pixelized filter with user determined pixel sizes	//BlackandWhite(); // turn the image into black and white only with a changeable threshold	//emboss(); // create an emboss depth effect	//edgeDetection(); // detect edges by comparing neighboring pixels and exaggerating the difference	//gaussianBlur(); // Blur image according to gaussian (normal) distribution	//diskBlur();	//diskBlurDetect();	diskBlurEmboss();	while(1);}void BlackandWhite(){	// local variables	int x, y;	unsigned char r, g, b, avR, avG, avB, average1, average2;	// loop through all x's and y's	for(y=0; y < YSIZE; y++)	{		for(x=0; x < XSIZE; x++)		{			// read RGB values of each pixel			r += *(((unsigned char*)imgBuffer) + (((y * XSIZE) + x ) * 4) + 3);			g += *(((unsigned char*)imgBuffer) + (((y * XSIZE) + x ) * 4) + 2);			b += *(((unsigned char*)imgBuffer) + (((y * XSIZE) + x ) * 4) + 1);		}	}	// find the average pixel color in the picture	avR = r / NUM_PIXELS;	avG = g / NUM_PIXELS;	avB = b / NUM_PIXELS;	average1 = (avR + avG + avB) / 3;	// Convert	for(y=0; y < YSIZE; y++)	{		for(x=0; x<XSIZE; x++)		{			// read RGB values of each pixel			r = *(((unsigned char*)imgBuffer) + (((y * XSIZE) + x ) * 4) + 3);			g = *(((unsigned char*)imgBuffer) + (((y * XSIZE) + x ) * 4) + 2);			b = *(((unsigned char*)imgBuffer) + (((y * XSIZE) + x ) * 4) + 1);			average2 = (r + g + b) / 3;			//compare each pixel to average with threshold modifier and convert to black or white			if (average2 < average1 + 15 * BWModifier){				r = 0;				g = 0;				b = 0;			}			else{				r = 255;				g = 255;				b = 255;			}			//display new image			  *(((unsigned char*)newImg) + (((y * XSIZE) + x ) * 4) + 3) = r;			  *(((unsigned char*)newImg) + (((y * XSIZE) + x ) * 4) + 2) = g;			  *(((unsigned char*)newImg) + (((y * XSIZE) + x ) * 4) + 1) = b;		}	}}void pixelate(){	// local variables		int x, y, w, z, m, p;		unsigned char r, g, b;		// loop through x's and y's while skipping the number of pixelModifier to create similar pixels			for(y=0; y < YSIZE; y+=pixelModifier)			{				for(x=0; x < XSIZE; x+=pixelModifier)				{					// read RGB values of each pixel					r = *(((unsigned char*)imgBuffer) + (((y * XSIZE) + x ) * 4) + 3);					g = *(((unsigned char*)imgBuffer) + (((y * XSIZE) + x ) * 4) + 2);					b = *(((unsigned char*)imgBuffer) + (((y * XSIZE) + x ) * 4) + 1);					//transfer current value of x and y to new vars to avoid changing them					w = y;					z = x;					m = w + pixelModifier;					p = z + pixelModifier;					//display same pixel over span of pixelModifier					for(w=y; w < m; w++)					{						for(z=x; z < p; z++)						{							*(((unsigned char*)newImg) + (((w * XSIZE) + z ) * 4) + 3) = r;							*(((unsigned char*)newImg) + (((w * XSIZE) + z ) * 4) + 2) = g;							*(((unsigned char*)newImg) + (((w * XSIZE) + z ) * 4) + 1) = b;						}					}				}			}}void emboss(){	//local vars	int x, y, w, z;	unsigned char r, g, b, invR, invG, invB, finalR, finalG, finalB;	// loop through all x's and y's	for(y=0; y < YSIZE; y++)	{		for(x=0; x < XSIZE; x++)		{			// read RGB values of each pixel			r = *(((unsigned char*)imgBuffer) + (((y * XSIZE) + x ) * 4) + 3);			g = *(((unsigned char*)imgBuffer) + (((y * XSIZE) + x ) * 4) + 2);			b = *(((unsigned char*)imgBuffer) + (((y * XSIZE) + x ) * 4) + 1);			//invert each pixel and store it in new variable			invR = 255 - r;			invG = 255 - g;			invB = 255 - b;			// if overlapping pixel with inverse still not achieved, display black border			if ( x < embossDepth || y < embossDepth)			{				r = 0;				g = 0;				b = 0;				*(((unsigned char*)newImg) + (((y * XSIZE) + x ) * 4) + 3) = r;				*(((unsigned char*)newImg) + (((y * XSIZE) + x ) * 4) + 2) = g;				*(((unsigned char*)newImg) + (((y * XSIZE) + x ) * 4) + 1) = b;			}			else{				w = y - embossDepth;				z = x - embossDepth;				// get RGB values of in location before emboss to create shifted overlap effect				r = *(((unsigned char*)imgBuffer) + (((w * XSIZE) + z ) * 4) + 3);				g = *(((unsigned char*)imgBuffer) + (((w * XSIZE) + z ) * 4) + 2);				b = *(((unsigned char*)imgBuffer) + (((w * XSIZE) + z ) * 4) + 1);				finalR = (r + invR)/2;				finalG = (g + invG)/2;				finalB = (b + invB)/2;				*(((unsigned char*)newImg) + (((y * XSIZE) + x ) * 4) + 3) = finalR;				*(((unsigned char*)newImg) + (((y * XSIZE) + x ) * 4) + 2) = finalG;				*(((unsigned char*)newImg) + (((y * XSIZE) + x ) * 4) + 1) = finalB;			}		}	}}void edgeDetection(){	//local vars	int x, y, w;	unsigned char r, g, b, prevR, prevG, prevB, finalR, finalG, finalB;	// loop through all x's and y's	for(y=0; y < YSIZE; y++)	{		for(x=0; x < XSIZE; x++)		{			// read RGB values of each pixel			r = *(((unsigned char*)imgBuffer) + (((y * XSIZE) + x ) * 4) + 3);			g = *(((unsigned char*)imgBuffer) + (((y * XSIZE) + x ) * 4) + 2);			b = *(((unsigned char*)imgBuffer) + (((y * XSIZE) + x ) * 4) + 1);			// if overlapping pixel with inverse still not achieved, display black border			if (y < detectionParameter)			{				// do nothing if at first pixel			}			else{ //compare second y pixel line to previous and alter				w = y - detectionParameter;				// get RGB values of previous y line				prevR = *(((unsigned char*)imgBuffer) + (((w * XSIZE) + x ) * 4) + 3);				prevG = *(((unsigned char*)imgBuffer) + (((w * XSIZE) + x ) * 4) + 2);				prevB = *(((unsigned char*)imgBuffer) + (((w * XSIZE) + x ) * 4) + 1);				finalR = abs(prevR-r);				finalG = abs(prevG-g);				finalB = abs(prevB-b);				if (finalR > detectThreshold || finalG > detectThreshold || finalB > detectThreshold){					*(((unsigned char*)newImg) + (((y * XSIZE) + x ) * 4) + 3) = 255;					*(((unsigned char*)newImg) + (((y * XSIZE) + x ) * 4) + 2) = 255;					*(((unsigned char*)newImg) + (((y * XSIZE) + x ) * 4) + 1) = 255;				}				else{					*(((unsigned char*)newImg) + (((y * XSIZE) + x ) * 4) + 3) = 0;					*(((unsigned char*)newImg) + (((y * XSIZE) + x ) * 4) + 2) = 0;					*(((unsigned char*)newImg) + (((y * XSIZE) + x ) * 4) + 1) = 0;				}			}		}	}}void gaussianBlur(){		// local variables			int x, y, i, j, z, c;			unsigned char avR, avG, avB;			// loop through x's and y's while skipping the number of pixelModifier to create similar pixels				for(y=0; y < YSIZE; y++)				{					for(x=0; x < XSIZE; x++)					{						z = 0;						//Inner Matrix						for(i = 0; i < 5; i++)						{							for(j = 0; j < 5 ; j++)							{								// sum product of each entry of 5x5 matrix with corresponding Gaussian coefficient								Red [z] = *(((unsigned char*)imgBuffer) + ((((y+(i-2)) * XSIZE) + (x+(j-2)) ) * 4) + 3);								Green [z] = *(((unsigned char*)imgBuffer) + ((((y+(i-2)) * XSIZE) + (x+(j-2)) ) * 4) + 2);								Blue [z] = *(((unsigned char*)imgBuffer) + ((((y+(i-2)) * XSIZE) + (x+(j-2)) ) * 4) + 1);								z++;							}						}						avR = 0;						avG = 0;						avB = 0;						for (c = 0; c < 25 ; c++){							avR += Red[c] * GaussianDistributionCoeff[c];							avG += Green[c] * GaussianDistributionCoeff[c];							avB += Blue[c] * GaussianDistributionCoeff[c];						}						*(((unsigned char*)newImg) + (((y * XSIZE) + x ) * 4) + 3) = avR;						*(((unsigned char*)newImg) + (((y * XSIZE) + x ) * 4) + 2) = avG;						*(((unsigned char*)newImg) + (((y * XSIZE) + x ) * 4) + 1) = avB;					}				}}void diskBlur(){		// local variables			int x, y, i, j, z, c;			unsigned char avR, avG, avB;			// loop through x's and y's while skipping the number of pixelModifier to create similar pixels				for(y=0; y < YSIZE; y++)				{					for(x=0; x < XSIZE; x++)					{						z = 0;						//Inner Matrix						for(i = 0; i < 5; i++)						{							for(j = 0; j < 5 ; j++)							{								// sum product of each entry of 5x5 matrix with corresponding Gaussian coefficient								Red [z] = *(((unsigned char*)imgBuffer) + ((((y+(i-2)) * XSIZE) + (x+(j-2)) ) * 4) + 3);								Green [z] = *(((unsigned char*)imgBuffer) + ((((y+(i-2)) * XSIZE) + (x+(j-2)) ) * 4) + 2);								Blue [z] = *(((unsigned char*)imgBuffer) + ((((y+(i-2)) * XSIZE) + (x+(j-2)) ) * 4) + 1);								z++;							}						}						avR = 0;						avG = 0;						avB = 0;						for (c = 0; c < 25 ; c++){							avR += Red[c] * diskBlurCoeff[c];							avG += Green[c] * diskBlurCoeff[c];							avB += Blue[c] * diskBlurCoeff[c];						}						*(((unsigned char*)newImg) + (((y * XSIZE) + x ) * 4) + 3) = avR;						*(((unsigned char*)newImg) + (((y * XSIZE) + x ) * 4) + 2) = avG;						*(((unsigned char*)newImg) + (((y * XSIZE) + x ) * 4) + 1) = avB;					}				}}